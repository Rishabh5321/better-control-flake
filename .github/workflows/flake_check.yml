name: flake_check

on:
  push:
    branches:
      - main # Or your default branch, e.g., master
  pull_request:
    branches:
      - '*'
  workflow_dispatch:

jobs:
  flake-checks:
    name: flake_check
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install Nix
        uses: cachix/install-nix-action@v31
        with:
          install_url: https://nixos.org/nix/install
          extra_nix_config: |
            auto-optimise-store = true
            experimental-features = nix-command flakes
            download-buffer-size = 500000000 # Ensure integer

      - name: Setup Cachix
        uses: cachix/cachix-action@v16
        with:
          name: rishabh5321
          authToken: '${{ secrets.CACHIX_AUTH_TOKEN }}'

      - name: Run flake check and capture logs
        run: |
          set +e # Prevent script from exiting immediately on command failure

          echo "Running nix flake check..."
          # Run the command, capture output, and get exit code immediately
          OUTPUT=$(nix flake check 2>&1)
          EXIT_CODE=$?

          # Print the output to step logs and tee to file
          echo "$OUTPUT"
          echo "$OUTPUT" > flake_check.log # Use > instead of tee, tee can sometimes mask exit codes in complex pipes

          echo "Flake check exited with code: $EXIT_CODE"
          echo "FLAKE_CHECK_EXIT_CODE=$EXIT_CODE" >> $GITHUB_ENV

          # Set status and mark for failure based on exit code
          if [ "$EXIT_CODE" -eq 0 ]; then
            echo "FLAKE_CHECK_STATUS=passed" >> $GITHUB_ENV
          else
            echo "FLAKE_CHECK_STATUS=failed" >> $GITHUB_ENV
            echo "WORKFLOW_SHOULD_FAIL=true" >> $GITHUB_ENV # Ensure this is set on failure
          fi

          # Filter logs for reporting (excluding the specific warning)
          echo "$OUTPUT" | grep -v "The check omitted these incompatible systems:" > flake_check_filtered.log


      - name: Run flake install and capture logs
        run: |
          set +e # Prevent script from exiting immediately on command failure

          echo "Running nix profile install..."
          # Run the command, capture output, and get exit code immediately
          OUTPUT=$(nix profile install .#better-control 2>&1)
          EXIT_CODE=$?

          # Print the output to step logs and tee to file
          echo "$OUTPUT"
          echo "$OUTPUT" > flake_install.log # Use > instead of tee

          echo "Flake install exited with code: $EXIT_CODE"
          echo "FLAKE_INSTALL_EXIT_CODE=$EXIT_CODE" >> $GITHUB_ENV

          # Set status and mark for failure based on exit code
          if [ "$EXIT_CODE" -eq 0 ]; then
            echo "FLAKE_INSTALL_STATUS=passed" >> $GITHUB_ENV
          else
            echo "FLAKE_INSTALL_STATUS=failed" >> $GITHUB_ENV
            echo "WORKFLOW_SHOULD_FAIL=true" >> $GITHUB_ENV # Ensure this is set on failure
          fi

          # Filter logs for reporting (excluding the specific warning)
          echo "$OUTPUT" | grep -v "The check omitted these incompatible systems:" > flake_install_filtered.log


      - name: Debug Filtered Logs
        run: |
          echo "--- Filtered Flake Check Log (excluding incompatible systems warning) ---"
          cat flake_check_filtered.log || echo "(Log file not found or empty)"
          echo "-----------------------------------------------------------------------"
          echo "--- Filtered Flake Install Log (excluding incompatible systems warning) ---"
          cat flake_install_filtered.log || echo "(Log file not found or empty)"
          echo "-------------------------------------------------------------------------"


      - name: Send Telegram Notification
        if: always() # Runs regardless of previous step success/failure
        env:
          TELEGRAM_TOKEN: ${{ secrets.TELEGRAM_TOKEN }}
          CHAT_ID: ${{ secrets.CHAT_ID }}
        run: |
          BRANCH_NAME="${{ github.ref_name }}"
          REPO_NAME="${{ github.repository }}"

          # Use the filtered logs for the message content
          # Use < file or echo "$OUTPUT" for cat
          FLAKE_CHECK_LOG_CONTENT=$(cat flake_check_filtered.log 2>/dev/null | head -n 15 | perl -pe 's/\n/%0A/g')
          FLAKE_INSTALL_LOG_CONTENT=$(cat flake_install_filtered.log 2>/dev/null | head -n 15 | perl -pe 's/\n/%0A/g')

          # Add placeholder if logs are empty or file doesn't exist
          FLAKE_CHECK_LOG="${FLAKE_CHECK_LOG_CONTENT:-No relevant log messages.}"
          FLAKE_INSTALL_LOG="${FLAKE_INSTALL_LOG_CONTENT:-No relevant log messages.}"

          # Build status message based on environment variables set from exit codes
          CHECK_EMOJI="${{ env.FLAKE_CHECK_STATUS == 'passed' && '✅' || '❌' }}"
          INSTALL_EMOJI="${{ env.FLAKE_INSTALL_STATUS == 'passed' && '✅' || '❌' }}"

          # Overall status emoji
          OVERALL_EMOJI="❌"
          if [[ "${{ env.FLAKE_CHECK_STATUS }}" == "passed" && "${{ env.FLAKE_INSTALL_STATUS }}" == "passed" ]]; then
            OVERALL_EMOJI="✅"
          fi

          MESSAGE="$OVERALL_EMOJI Flake checks for $REPO_NAME on branch $BRANCH_NAME:%0A$CHECK_EMOJI Flake check: ${{ env.FLAKE_CHECK_STATUS }} (Exit Code: ${{ env.FLAKE_CHECK_EXIT_CODE }})%0A$INSTALL_EMOJI Flake install: ${{ env.FLAKE_INSTALL_STATUS }} (Exit Code: ${{ env.FLAKE_INSTALL_EXIT_CODE }})"

          MESSAGE+="%0A%0A<b>Flake Check Log (Filtered):</b>%0A<pre>$FLAKE_CHECK_LOG</pre>"
          MESSAGE+="%0A%0A<b>Flake Install Log (Filtered):</b>%0A<pre>$FLAKE_INSTALL_LOG</pre>"
          MESSAGE+="%0A%0AGenerated on $(TZ='Asia/Kolkata' date)"

          # Ensure message length does not exceed Telegram limit (approx 4096 bytes)
          MAX_LENGTH=4000
          if [ ${#MESSAGE} -gt $MAX_LENGTH ]; then
             MESSAGE="${MESSAGE:0:$MAX_LENGTH}... (truncated)"
          fi

          curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_TOKEN/sendMessage" \
            -d "chat_id=$CHAT_ID" \
            -d "text=$MESSAGE" \
            -d "parse_mode=HTML"


      # This step will fail the workflow if WORKFLOW_SHOULD_FAIL was set to true
      # in any previous step due to a non-zero exit code.
      - name: Fail Workflow If Errors Detected
        # This condition checks if the variable was set.
        if: env.WORKFLOW_SHOULD_FAIL == 'true'
        run: |
          echo "One or more Nix commands failed (indicated by non-zero exit code). Failing workflow."
          exit 1 # Explicitly exit with a non-zero status to fail the step and job