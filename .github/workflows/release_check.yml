# .github/workflows/update-better-control.yml
name: Update better-control version

on:
  schedule:
    # Runs hourly (adjust as needed, e.g., '0 8 * * *' for daily at 8 AM UTC)
    - cron: '0 * * * *'
  workflow_dispatch: # Allows manual triggering

jobs:
  update-better-control:
    runs-on: ubuntu-latest
    # Prevent multiple runs for the same commit/event
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: true

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Fetch all history for accurate version comparison and branch operations
          fetch-depth: 0

      - name: Install Nix
        uses: cachix/install-nix-action@v31
        with:
          # Use nixpkgs-unstable channel for potentially newer tools
          nix_path: nixpkgs=channel:nixos-unstable

      - name: Install dependencies (using Nix)
        run: |
          # Install necessary tools using nix profile for better isolation
          nix profile install nixpkgs#gh nixpkgs#nix-prefetch-github nixpkgs#jq nixpkgs#gnused nixpkgs#gnugrep

          # Add Nix binaries to PATH for subsequent steps
          echo "$HOME/.nix-profile/bin" >> $GITHUB_PATH
          # Verify installation
          gh --version
          nix-prefetch-github --version
          jq --version
          sed --version || true # gnu sed might not have --version
          grep --version || true # gnu grep might not have --version

          - name: Get current and determine latest version
          id: versions
          env:
            GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
            TARGET_REPO: "quantumvoid0/better-control"
          run: |
            CURRENT_VERSION=$(grep -oP 'version\s*=\s*"\K[^"]+' package.nix || echo "0.0.0")
            echo "Current version found in package.nix: $CURRENT_VERSION"
            echo "CURRENT_VERSION=$CURRENT_VERSION" >> $GITHUB_ENV
  
            # --- MODIFIED SECTION: Find the latest tag via GitHub API ---
            echo "Fetching all tags via GitHub API for $TARGET_REPO..."
            # Use gh api to list tags, jq to extract just the tag names.
            # Increase per_page if you expect more than 100 tags.
            # Use 'sort -V' for version sorting (available on standard Linux runners)
            # Use 'tail -n 1' to get the highest version after sorting.
            TAG_LIST_JSON=$(gh api "repos/$TARGET_REPO/tags?per_page=100")
            if [ -z "$TAG_LIST_JSON" ] || [ "$(echo "$TAG_LIST_JSON" | jq 'length')" -eq 0 ]; then
               echo "::warning::No tags found via GitHub API for repository $TARGET_REPO. Trying releases as fallback."
               # Fallback: Try listing releases and getting the latest tag name (less ideal)
               LATEST_VERSION=$(gh release list --repo "$TARGET_REPO" --limit 1 --json tagName --jq '.[0].tagName')
               if [ -z "$LATEST_VERSION" ] || [ "$LATEST_VERSION" == "null" ]; then
                  echo "::error::Could not find any tags via API or any releases via gh release list for $TARGET_REPO."
                  exit 1
               fi
               echo "Found latest release tag as fallback: $LATEST_VERSION"
            else
               echo "Sorting tags fetched via API..."
               # Extract names, sort using version sort (-V), get the last (highest) one
               LATEST_VERSION=$(echo "$TAG_LIST_JSON" | jq -r '.[].name' | sort -V | tail -n 1)
               if [ -z "$LATEST_VERSION" ]; then
                  echo "::error::Failed to extract or sort latest version from API tag list."
                  echo "API Response snippet: $(echo "$TAG_LIST_JSON" | head)"
                  exit 1
               fi
               echo "Latest version tag found via API and version sort: $LATEST_VERSION"
            fi
            # --- END OF MODIFIED SECTION ---
  
            # --- Rest of the step remains the same ---
            # Often tags have 'v' prefix, remove it for comparison if necessary
            # LATEST_VERSION=${LATEST_VERSION#v} # Uncomment if tags are like v1.2.3 and package.nix doesn't use 'v'
            echo "LATEST_VERSION=$LATEST_VERSION" >> $GITHUB_ENV
  
            if [ "$CURRENT_VERSION" = "$LATEST_VERSION" ]; then
              echo "better-control is up-to-date ($CURRENT_VERSION)."
              echo "UPDATE_NEEDED=false" >> $GITHUB_ENV
            else
              echo "Update needed: $CURRENT_VERSION -> $LATEST_VERSION"
              echo "UPDATE_NEEDED=true" >> $GITHUB_ENV
            fi

      - name: Check for existing Pull Request
        id: check_pr
        # Only run if an update is potentially needed
        if: env.UPDATE_NEEDED == 'true'
        env:
          # GITHUB_TOKEN needed for gh cli to interact with the repo
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # Define branch name early using the determined LATEST_VERSION
          BRANCH_NAME: "update-better-control-${{ env.LATEST_VERSION }}"
          # Define the base branch for the PR
          BASE_BRANCH: "main" # <<< IMPORTANT: Change this if your default branch is different >>>
        run: |
          echo "Checking for existing open PR for branch: $BRANCH_NAME targeting $BASE_BRANCH"
          # Use gh pr list to find open PRs targeting the base branch from the head branch
          EXISTING_PR_URL=$(gh pr list --head "$BRANCH_NAME" --base "$BASE_BRANCH" --state open --json url --jq '.[0].url')

          if [ -n "$EXISTING_PR_URL" ]; then
            echo "::warning::An open pull request already exists for branch $BRANCH_NAME: $EXISTING_PR_URL"
            echo "Skipping update and PR creation steps."
            echo "PR_EXISTS=true" >> $GITHUB_ENV
          else
            echo "No existing open PR found for branch $BRANCH_NAME."
            echo "PR_EXISTS=false" >> $GITHUB_ENV
          fi

      - name: Update version and hash
        # Only run if update is needed AND no existing PR was found
        if: env.UPDATE_NEEDED == 'true' && env.PR_EXISTS == 'false'
        env:
           # Pass LATEST_VERSION to this step's environment
           LATEST_VERSION: ${{ env.LATEST_VERSION }}
           TARGET_REPO_OWNER: "quantumvoid0"
           TARGET_REPO_NAME: "better-control"
        run: |
          echo "Updating package.nix to version $LATEST_VERSION"

          # Update version string using GNU sed for portability and -E for extended regex
          # Using @ as delimiter to avoid issues with version numbers
          sed -i -E "s@(version\s*=\s*\")[^\"]+@\1${LATEST_VERSION}@" package.nix
          echo "Version updated in package.nix"

          # Run nix-prefetch-github and capture all output
          echo "Running: nix-prefetch-github $TARGET_REPO_OWNER $TARGET_REPO_NAME --rev $LATEST_VERSION"
          # Prefetch without token by default, add --token if hitting rate limits and pass a secret
          PREFETCH_OUTPUT=$(nix-prefetch-github "$TARGET_REPO_OWNER" "$TARGET_REPO_NAME" --rev "$LATEST_VERSION" 2>&1)
          echo "Prefetch output:"
          echo "$PREFETCH_OUTPUT"

          # Extract hash from output (prefer JSON)
          NEW_HASH="" # Initialize NEW_HASH
          # Use jq -e to check for validity and extract in one go if possible
          if echo "$PREFETCH_OUTPUT" | jq -e .hash > /dev/null 2>&1; then
             # Use jq -r to get the raw hash string without JSON quotes
             NEW_HASH=$(echo "$PREFETCH_OUTPUT" | jq -r .hash)
             echo "Extracted hash via jq: $NEW_HASH"
          else
             echo "::warning::nix-prefetch-github did not produce valid JSON output. Attempting legacy extraction."
             # Attempt to extract legacy format (hash only) using grep with Perl regex
             LEGACY_HASH=$(echo "$PREFETCH_OUTPUT" | grep -oP 'sha256-[a-zA-Z0-9/+]+=*')
             if [ -n "$LEGACY_HASH" ]; then
                # Take the first match if multiple lines somehow exist
                NEW_HASH=$(echo "$LEGACY_HASH" | head -n 1)
                echo "Extracted legacy hash via grep: $NEW_HASH"
             else
                echo "::error::Failed to extract hash from prefetch output (JSON and Legacy methods failed)."
                echo "Output was: $PREFETCH_OUTPUT"
                exit 1
             fi
          fi

          # --- Improved Hash Validation ---
          # Validate hash format more strictly (starts with sha256-, followed by Base64 chars and optional padding)
          if [[ "$NEW_HASH" =~ ^sha256-[A-Za-z0-9+/]+={0,2}$ ]]; then
              echo "Validated hash format: $NEW_HASH"
          else
              echo "::error::Extracted value '$NEW_HASH' does not look like a valid sha256 hash."
              exit 1
          fi

          # --- Corrected SED command for HASH update ---
          # Use capture groups to replace only the content *between* the quotes.
          # Uses GNU sed with -E for extended regex. Delimiter is '|'.
          sed -i -E "s|(hash\s*=\s*\")[^\"]+(\";)|\1${NEW_HASH}\2|" package.nix

          # --- Verification ---
          # Verify that the hash was actually updated correctly in the file
          if grep -q "hash = \"$NEW_HASH\";" package.nix; then
            echo "Successfully updated hash in package.nix"
          else
            echo "::error::Failed to verify hash update in package.nix using sed."
            echo "Expected hash line: hash = \"$NEW_HASH\";"
            echo "File content after attempted update:"
            cat package.nix
            exit 1
          fi

      - name: Commit and push changes
        # Only run if update is needed AND no existing PR was found
        if: env.UPDATE_NEEDED == 'true' && env.PR_EXISTS == 'false'
        env:
           # Pass LATEST_VERSION and define branch name again for clarity
           LATEST_VERSION: ${{ env.LATEST_VERSION }}
           BRANCH_NAME: "update-better-control-${{ env.LATEST_VERSION }}"
        run: |
          echo "Configuring Git user..."
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          echo "Checking out branch $BRANCH_NAME..."
          # Create or switch to the update branch
          git checkout -B "$BRANCH_NAME"

          echo "Adding changes..."
          git add package.nix

          # Check if there are actual changes staged for commit
          if git diff --staged --quiet; then
             echo "No changes detected in package.nix after update. Skipping commit and push."
             # Set an output or env var if subsequent steps depend on changes being pushed
             echo "CHANGES_PUSHED=false" >> $GITHUB_ENV
          else
             echo "Committing changes..."
             git commit -m "feat: Update better-control to ${LATEST_VERSION}" -m "Automatic update via GitHub Actions."

             echo "Pushing changes to origin/$BRANCH_NAME..."
             # Force push is generally acceptable here since we manage this branch
             # and checked for existing PRs. It ensures the branch reflects this specific run.
             git push -f origin "$BRANCH_NAME"
             echo "Changes pushed successfully."
             echo "CHANGES_PUSHED=true" >> $GITHUB_ENV
          fi

      - name: Create Pull Request
        # Only run if update is needed, no existing PR was found, AND changes were pushed
        if: env.UPDATE_NEEDED == 'true' && env.PR_EXISTS == 'false' && env.CHANGES_PUSHED == 'true'
        uses: actions/github-script@v7
        env:
          # Pass necessary versions and branch name to the script context
          CURRENT_VERSION: ${{ env.CURRENT_VERSION }}
          LATEST_VERSION: ${{ env.LATEST_VERSION }}
          BRANCH_NAME: "update-better-control-${{ env.LATEST_VERSION }}"
          # Define the base branch for the PR again
          BASE_BRANCH: "main" # <<< IMPORTANT: Change this if your default branch is different >>>
        with:
          # Grant the script permission to create PRs
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { CURRENT_VERSION, LATEST_VERSION, BRANCH_NAME, BASE_BRANCH } = process.env;
            // Ensure variables are available
            if (!LATEST_VERSION || !BRANCH_NAME || !CURRENT_VERSION || !BASE_BRANCH) {
              core.setFailed('Required environment variables (CURRENT_VERSION, LATEST_VERSION, BRANCH_NAME, BASE_BRANCH) were not set for PR creation.');
              return;
            }

            const title = `feat: Update better-control to ${LATEST_VERSION}`;
            const body = `This PR automatically updates the \`better-control\` package from version \`${CURRENT_VERSION}\` to \`${LATEST_VERSION}\`.

            This version was determined by finding the highest version tag available in the repository.

            Changes generated by GitHub Actions workflow.`;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            console.log(`Attempting to create Pull Request:`);
            console.log(`  Title: ${title}`);
            console.log(`  Head: ${owner}:${BRANCH_NAME}`);
            console.log(`  Base: ${BASE_BRANCH}`);

            try {
              // The check_pr step should prevent this from running if a PR exists,
              // but this check adds robustness.
              const { data: existingPulls } = await github.rest.pulls.list({
                owner,
                repo,
                state: 'open',
                head: `${owner}:${BRANCH_NAME}`,
                base: BASE_BRANCH,
              });

              if (existingPulls.length > 0) {
                console.log(`::warning::Pull request from ${BRANCH_NAME} to ${BASE_BRANCH} already exists: ${existingPulls[0].html_url}`);
                console.log('Skipping new PR creation.');
              } else {
                console.log('No existing open PR found. Creating a new one...');
                const { data: pullRequest } = await github.rest.pulls.create({
                  owner,
                  repo,
                  title,
                  head: BRANCH_NAME, // Use just the branch name for head within the same repo
                  base: BASE_BRANCH,
                  body: body,
                });
                console.log(`Pull request created successfully: ${pullRequest.html_url}`);
                // Optionally add labels or assignees here
                // await github.rest.issues.addLabels({ owner, repo, issue_number: pullRequest.number, labels: ['dependencies', 'automated'] });
              }
            } catch (error) {
               // Check if error is because the branch wasn't pushed (e.g., no changes)
               if (error.message.includes("No commit found for the ref") || error.status === 422) { // 422 Unprocessable Entity can indicate validation errors like head/base mismatch
                  console.warn(`Could not create PR. This might be because the branch '${BRANCH_NAME}' wasn't pushed (no changes detected?), the base branch '${BASE_BRANCH}' is incorrect, or another issue occurred. Error: ${error.message}`);
               } else {
                  core.setFailed(`Failed to create or check for pull request for branch ${BRANCH_NAME}: ${error.message}`);
               }
            }